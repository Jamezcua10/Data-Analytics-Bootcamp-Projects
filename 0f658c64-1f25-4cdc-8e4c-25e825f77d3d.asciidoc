
Hi James. I’m Svetlana and will review your project. I’ve added all my
comments to new cells with different coloring. Please don’t delete my
comments.

The first time I see a mistake, I’ll just point it out and let you find
it and fix it yourself. In a real job, your boss will do the same, and
I’m trying to prepare you to work as an Data Analyst. But if you can’t
handle this task yet, I’ll give you a more accurate hint at the next
check.

Reviewer’s comment v. 1:

If you did something great I’m using green color for my comment

Reviewer’s comment v. 1:

If I want to give you advice or think that something can be improved,
then I’ll use yellow. This is an optional recommendation.

Reviewer’s comment v. 1:

If the topic requires some extra work so I can accept it then the color
will be red

== Review v. 1

You’ve done a really good job! While there’s room for improvement, on
the whole, your project is looking good. There are few things that need
to be corrected in your project. They’re mostly minor issues that are
easy to fix. There are also some comments for improvement. They don’t
mean that you’ve done anything wrong, but they’re things we wanted to
point out that can help you further develop your skills. Every issue
with our code is a chance for us to learn something new. Good luck!

== Review v. 2

Thank you for sending in your project again. It seems like something
went wrong and you sent a version without any changes. Please check it
again. I have checked it several times, but I haven’t find changes…
You’re on the right track. Just a few tiny corrections before your
project is done!

== Review v. 3

You’ve worked hard and now your project is perfect! I’m glad to say that
your project has been accepted. Keep up the good work, and good luck on
the next sprint!

== Analyzing borrowers’ risk of defaulting¶

Your project is to prepare a report for a bank’s loan division. You’ll
need to find out if a customer’s marital status and number of children
has an impact on whether they will default on a loan. The bank already
has some data on customers’ credit worthiness.

Your report will be considered when building a credit scoring of a
potential customer. A credit scoring is used to evaluate the ability of
a potential borrower to repay their loan.

Reviewer’s comment v. 1:

Well done that you described the project, but it will be better to
formulate a goal of it.

== Step 1. Open the data file and have a look at the general information


+*In[1]:*+
[source, ipython3]
----
import pandas as pd
data = pd.read_csv('/datasets/credit_scoring_eng.csv')
creditScore = pd.DataFrame(data=data)
----


+*In[2]:*+
[source, ipython3]
----
data.info()
----


+*Out[2]:*+
----
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 21525 entries, 0 to 21524
Data columns (total 12 columns):
children            21525 non-null int64
days_employed       19351 non-null float64
dob_years           21525 non-null int64
education           21525 non-null object
education_id        21525 non-null int64
family_status       21525 non-null object
family_status_id    21525 non-null int64
gender              21525 non-null object
income_type         21525 non-null object
debt                21525 non-null int64
total_income        19351 non-null float64
purpose             21525 non-null object
dtypes: float64(2), int64(5), object(5)
memory usage: 2.0+ MB
----


+*In[3]:*+
[source, ipython3]
----
data.head()
----


+*Out[3]:*+
----
[cols=",,,,,,,,,,,,",options="header",]
|===
| |children |days_employed |dob_years |education |education_id
|family_status |family_status_id |gender |income_type |debt
|total_income |purpose
|0 |1 |-8437.673028 |42 |bachelor's degree |0 |married |0 |F |employee
|0 |40620.102 |purchase of the house

|1 |1 |-4024.803754 |36 |secondary education |1 |married |0 |F |employee
|0 |17932.802 |car purchase

|2 |0 |-5623.422610 |33 |Secondary Education |1 |married |0 |M |employee
|0 |23341.752 |purchase of the house

|3 |3 |-4124.747207 |32 |secondary education |1 |married |0 |M |employee
|0 |42820.568 |supplementary education

|4 |0 |340266.072047 |53 |secondary education |1 |civil partnership |1
|F |retiree |0 |25378.572 |to have a wedding
|===
----

== Step 2. Data Preprocessing

== Processing missing values


+*In[4]:*+
[source, ipython3]
----
# handle negative or missing children
creditScore['children'] = creditScore['children'].replace(-1,0)
creditScore['children'] = creditScore['children'].replace(20,0)
creditScore['children'].fillna(0,inplace=True)

#handle missing days employee 
creditScore['days_employed'].fillna(0,inplace=True)

#handle missing total income
creditScore['total_income'].fillna(0,inplace=True)
print(creditScore.duplicated().sum())
----


+*Out[4]:*+
----
54
----

For the processing missing values step, I was able to identified three
columns that had missing values: `children, ’days_employed' and
`total_income'. I filled all missing values with a 0 to simply identify
non-existent values in our dataset. In the `children' column, there were
rows that contained a negative value and rows that contained an outlier
value. It appears to be that these might be data entry errors, as it is
impossible to have a negative amount of children and it is very unlikely
to have 20 children. I replaced the values in these rows with 0. Any
other rows with missing values was giving a default value of 0 children.
In the `days_employed' and `total_income' columns, I replaced null
values with 0 in order to fill in those missing values.

Reviewer’s comment v. 1:

Please note that you can also change ``-1'' and ``20'' values to ``1''
and ``2'', respectively.

Reviewer’s comment v. 1:

Could you please explain a possible reasons of a missing values? Please
explain why you filled a missing values by 0.

Reviewer’s comment v. 3:

Yes, you are right :)



== Data type replacement


+*In[5]:*+
[source, ipython3]
----
# change float type to int for days_employed
creditScore['days_employed']= creditScore['days_employed'].astype(int)

for days in creditScore['days_employed']:
    if days < 0:
        creditScore['days_employed'] = creditScore['days_employed'].replace(days,0)
        
creditScore['years_employed'] = (creditScore['days_employed']/365).astype(int).round()

#change float type to int for total_income
creditScore['total_income']= creditScore['total_income'].astype(int)

#handle duplicates in education
creditScore['education'] = creditScore['education'].str.lower()

#handle duplicates in purpose 
import nltk
from nltk.stem import WordNetLemmatizer

wordnet_lemma = WordNetLemmatizer()

for purpose in creditScore['purpose']:
    words = nltk.word_tokenize(purpose)
    
    if 'education' in words or 'university' in words or 'educated' in words:
        creditScore['purpose'].replace(purpose, 'education', inplace=True)
        
    if 'car' in words or 'cars' in words:
        creditScore['purpose'].replace(purpose, 'car',inplace=True)
        
    if 'house' in words or 'housing' in words or 'estate' in words or 'property' in words:
        creditScore['purpose'].replace(purpose,'real estate',inplace=True)
        
    if 'wedding' in words:
        creditScore['purpose'].replace(purpose,'wedding',inplace=True)
        
print(creditScore['purpose'].unique())
                                               
----


+*Out[5]:*+
----
['real estate' 'car' 'education' 'wedding']
----

In this data type replacement step, I started my handling the
`days_employed' column. I believe that this column is quite corrupted as
there are many empty values or absurdly high values. To handle this
column, I changed the type of the column from float to int, then I
changed any negative value for this column to 0 (if you have been
employed for a negative amount of time, then you have not been employed
for that amount of time and therefore, your days employed are 0) and
then I went through each value to change the number from days to years
for ease of readibility then stored this new years value in a new
column, years_employed. Even after this cleanup, there are still very
strange values - looking at the first 30 rows in this column yields
either 0 years employed or between 932 to 1096 years of employment,
which is not possible.

For the `total_income' column, I changed the type of the column from
float to int to make it easier to read the numbers. For the `education'
column, there were many of the same values but with different casing
(for example, `secondary education' and `Secondary Education' are the
same value but because of the capitilization difference, are stored
differently). I used the str.lower() method to lower case all of the
values which removes this unnecessary repetition.

The `purpose' column was very problematic because there were many
purposes that were essentially the same but because of the different
wording, was stored differently. For example, `to have a wedding' and
`wedding ceremony' are the same purpose but worded differently so will
be handed as different reasons. We don’t want this so I used
lemmatization to find all unique identifiable words in the raw purpose
output and from that, categorized the purpose accordingly.


+*In[6]:*+
[source, ipython3]
----
def alert_income(income):
    if income <= 25000 :
        return 'low'
    if income <= 50000 :
        return 'median'
    return 'high'

creditScore['alert_income'] = creditScore['total_income'].apply(alert_income)
creditScore['alert_income'].value_counts()




----


+*Out[6]:*+
----low       12924
median     7281
high       1320
Name: alert_income, dtype: int64----

For the total_income column, I used the apply method to categorize
customer’s total income level. Using this technique gives us a better
understanding on where customers fall in the income bracket. Customers
whose total income is below 25,000 are considered low income and make up
the largest group in our dataset. Customers whose total income is
between 25,000 and 50,000 are considered median income and make up the
second largest group our dataset. Customers whose total income is
greater than 50,000 are considered high income and are the smallest
group in our dataset.


+*In[7]:*+
[source, ipython3]
----
def alert_children(children):
    if children <= 0:
        return' no child'
    if children <= 1:
        return ' one child'
    if children <= 5:
        return ' more than one child'

creditScore['alert_children'] = creditScore['children'].apply(alert_children)
creditScore['alert_children'].value_counts()
----


+*Out[7]:*+
---- no child               14272
 one child               4818
 more than one child     2435
Name: alert_children, dtype: int64----

For the children column, I also used the apply method to categorize the
number of children of each customer. A great portion of our data set
contains customers who have no children.

Reviewer’s comment v. 1:

Well done that you categorized `purpose' column, but please add
categorization of the total_income and number of children columns.

Reviewer’s comment v. 3:

Well done that you added categorizatiob for the total_income and number
of children columns.

Reviewer’s comment v. 1:

It’s great that you brought the data to the desired formats.

Maybe this link will beinteresting for you:
https://stackabuse.com/python-for-nlp-tokenization-stemming-and-lemmatization-with-spacy-library/

== Processing Duplicates


+*In[8]:*+
[source, ipython3]
----
creditScore.duplicated(keep=False).value_counts(normalize=True) * 100
----


+*Out[8]:*+
----False    96.8223
True      3.1777
dtype: float64----


+*In[9]:*+
[source, ipython3]
----
#print(creditScore.duplicated().sum())
creditScore = creditScore.drop_duplicates().reset_index(drop=True)
----


+*In[10]:*+
[source, ipython3]
----
creditScore.drop_duplicates()
----


+*Out[10]:*+
----
[cols=",,,,,,,,,,,,,,,",options="header",]
|===
| |children |days_employed |dob_years |education |education_id
|family_status |family_status_id |gender |income_type |debt
|total_income |purpose |years_employed |alert_income |alert_children
|0 |1 |0 |42 |bachelor's degree |0 |married |0 |F |employee |0 |40620
|real estate |0 |median |one child

|1 |1 |0 |36 |secondary education |1 |married |0 |F |employee |0 |17932
|car |0 |low |one child

|2 |0 |0 |33 |secondary education |1 |married |0 |M |employee |0 |23341
|real estate |0 |low |no child

|3 |3 |0 |32 |secondary education |1 |married |0 |M |employee |0 |42820
|education |0 |median |more than one child

|4 |0 |340266 |53 |secondary education |1 |civil partnership |1 |F
|retiree |0 |25378 |wedding |932 |median |no child

|... |... |... |... |... |... |... |... |... |... |... |... |... |...
|... |...

|21112 |1 |0 |43 |secondary education |1 |civil partnership |1 |F
|business |0 |35966 |real estate |0 |median |one child

|21113 |0 |343937 |67 |secondary education |1 |married |0 |F |retiree |0
|24959 |car |942 |low |no child

|21114 |1 |0 |38 |secondary education |1 |civil partnership |1 |M
|employee |1 |14347 |real estate |0 |low |one child

|21115 |3 |0 |38 |secondary education |1 |married |0 |M |employee |1
|39054 |car |0 |median |more than one child

|21116 |2 |0 |40 |secondary education |1 |married |0 |F |employee |0
|13127 |car |0 |low |more than one child
|===

21117 rows × 15 columns
----

In this processing duplicates step, I identified 408 duplicates in the
data. We have duplicates in our data due to the differences in string
cases and also duplicates by meaning in the ``purpose'' column. I
decided to drop all of these duplicates using the drop_duplicated()
method.

Reviewer’s comment v. 1:

Do you have any suggestions why we have duplicates in our data?

Please calculate the percentage of duplicates. The percentage of
duplicates in the entire data is important to know before making a
decision about removing duplicates.

Reviewer’s comment v. 1:

Please note that it’s necessary to add a conclusion for each part of the
project.

Reviewer’s comment v. 3:

👍👍👍

== Step 3. Answer these questions

Is there a relation between having kids and repaying a loan on time?


+*In[11]:*+
[source, ipython3]
----
kidsData = creditScore.groupby('children')
print(kidsData['debt'].describe())
print(kidsData['debt'].count()/kidsData['debt'].sum())
----


+*Out[11]:*+
----
            count      mean       std  min  25%  50%  75%  max
children                                                      
0         13949.0  0.076708  0.266137  0.0  0.0  0.0  0.0  1.0
1          4751.0  0.093454  0.291098  0.0  0.0  0.0  0.0  1.0
2          2039.0  0.095145  0.293487  0.0  0.0  0.0  0.0  1.0
3           329.0  0.082067  0.274885  0.0  0.0  0.0  0.0  1.0
4            40.0  0.100000  0.303822  0.0  0.0  0.0  0.0  1.0
5             9.0  0.000000  0.000000  0.0  0.0  0.0  0.0  0.0
children
0    13.036449
1    10.700450
2    10.510309
3    12.185185
4    10.000000
5          inf
Name: debt, dtype: float64
----


+*In[12]:*+
[source, ipython3]
----
creditScore.pivot_table(index = 'children',values = 'debt', aggfunc = ['count', 'mean'])
----


+*Out[12]:*+
----
count

mean

debt

debt

children

0

13949

0.076708

1

4751

0.093454

2

2039

0.095145

3

329

0.082067

4

40

0.100000

5

9

0.000000
----

I started by grouping the data by the `children' column. There are 13949
rows with 0 children, 4751 rows with 1 child, 2039 rows with 2 children,
329 rows with 3 children, 40 rows with 4 children and 9 rows with 5
children.

Looking at the `debt' column within this data grouping, there are 1070
rows with debt and 0 children, 444 rows with debt and 1 child, 194 rows
with debt and 2 children, 27 rows with debt and 3 children, 4 rows with
debt and 4 children and 0 rows with debt and 5 children.

Putting these two numbers together: 13.0% of rows with 0 children have
debt, 10.7% of rows with 1 child have debt, 10.5% of rows with 2
children have debt, 12.1% of rows with 3 children have debt, 10% of with
4 children have debt and 0% of rows with 5 children have debt.

From this data, we can conclude that there is a relation between having
kids and paying debt on time. The rows with more children are more
likely to repay their loans on time, with the exception of the rows with
3 children.

Reviewer’s comment v. 1:

It’s great that you clearly analysed data, but please add categorization
for the number of children.

Reviewer’s comment v. 3:

An excellent analysis :)

Is there a relation between marital status and repaying a loan on time?


+*In[13]:*+
[source, ipython3]
----
maritalData = creditScore.groupby('family_status')
print(maritalData['debt'].describe())
print(maritalData['debt'].count()/maritalData['debt'].sum())
----


+*Out[13]:*+
----
                     count      mean       std  min  25%  50%  75%  max
family_status                                                          
civil partnership   4124.0  0.094083  0.291980  0.0  0.0  0.0  0.0  1.0
divorced            1193.0  0.071249  0.257348  0.0  0.0  0.0  0.0  1.0
married            12074.0  0.076942  0.266511  0.0  0.0  0.0  0.0  1.0
unmarried           2784.0  0.098420  0.297935  0.0  0.0  0.0  0.0  1.0
widow / widower      942.0  0.066879  0.249945  0.0  0.0  0.0  0.0  1.0
family_status
civil partnership    10.628866
divorced             14.035294
married              12.996771
unmarried            10.160584
widow / widower      14.952381
Name: debt, dtype: float64
----


+*In[14]:*+
[source, ipython3]
----
creditScore.pivot_table(index = 'family_status',values = 'debt', aggfunc = ['count', 'mean'])
----


+*Out[14]:*+
----
count

mean

debt

debt

family_status

civil partnership

4124

0.094083

divorced

1193

0.071249

married

12074

0.076942

unmarried

2784

0.098420

widow / widower

942

0.066879
----

I started by grouping the data by the `family_status' column.

Looking at the data: 388/4124 = 14.9% of those who are widows have debt,
14.0% of those who are divorced have debt, 13% of those who are married
have debt,10.6% of those in a civil partnership have debt, 10.1% of
those who are unmarried have debt.

From this data, we can conclude that there is a relation between martial
status and repaying the debt on time. Those who either have been married
(widows, divorced) or are married are more likely to have debt than
those who are unmarried (either single or in a civil partnership).

Reviewer’s comment v. 1:

Yes, an excellent analysis :)

Is there a relation between income level and repaying a loan on time?


+*In[15]:*+
[source, ipython3]
----
incomeData = creditScore.groupby('income_type')
print(incomeData['debt'].describe())
print(incomeData['debt'].count()/incomeData['debt'].sum())
----


+*Out[15]:*+
----
                               count      mean       std  min   25%  50%  \
income_type                                                                
business                      5032.0  0.074722  0.262968  0.0  0.00  0.0   
civil servant                 1450.0  0.059310  0.236286  0.0  0.00  0.0   
employee                     10899.0  0.097165  0.296196  0.0  0.00  0.0   
entrepreneur                     2.0  0.000000  0.000000  0.0  0.00  0.0   
paternity / maternity leave      1.0  1.000000       NaN  1.0  1.00  1.0   
retiree                       3730.0  0.057909  0.233602  0.0  0.00  0.0   
student                          1.0  0.000000       NaN  0.0  0.00  0.0   
unemployed                       2.0  0.500000  0.707107  0.0  0.25  0.5   

                              75%  max  
income_type                             
business                     0.00  1.0  
civil servant                0.00  1.0  
employee                     0.00  1.0  
entrepreneur                 0.00  0.0  
paternity / maternity leave  1.00  1.0  
retiree                      0.00  1.0  
student                      0.00  0.0  
unemployed                   0.75  1.0  
income_type
business                       13.382979
civil servant                  16.860465
employee                       10.291785
entrepreneur                         inf
paternity / maternity leave     1.000000
retiree                        17.268519
student                              inf
unemployed                      2.000000
Name: debt, dtype: float64
----


+*In[16]:*+
[source, ipython3]
----
creditScore.pivot_table(index = 'income_type',values = 'debt', aggfunc = ['count', 'mean'])
----


+*Out[16]:*+
----
count

mean

debt

debt

income_type

business

5032

0.074722

civil servant

1450

0.059310

employee

10899

0.097165

entrepreneur

2

0.000000

paternity / maternity leave

1

1.000000

retiree

3730

0.057909

student

1

0.000000

unemployed

2

0.500000
----

I started by grouping the data by the `income_type' column.

Looking at the data: 376/5032 = 13.3% of those who own a business have
debt, 86/1450 = 16.8% of those who are civil servants have debt,
1059/10899 = 10.3% of those who are employees have debt, neither of the
two entrepreneurs in the data have debt, the 1 row on
paternity/maternity leave have debt, 216/3730 = 17.2% of retirees have
debt, the 1 student in the data does not have debt, and only 1 of the 2
unemployed in the data have debt.

From this data, we can conclude that there is a relation income level
and repaying the loan on time. Those who either were employed (retired)
or are employed by an external entity (business, civil servent,
employee) have high percentage of debt than those who are either self
employed (entrepreneur), on paternity / maternity leave, a student or
unemployed.

Reviewer’s comment v. 1:

Could you please add categorization of the income level and analyse data
clearly?

Reviewer’s comment v. 3:

Please note that you can also use a correlation function to check
dependency between variables. However, please take into account that it
shows only linear dependecy between variables. Maybe this link will be
interesting for you:
https://machinelearningmastery.com/how-to-use-correlation-to-understand-the-relationship-between-variables/.

How do different loan purposes affect on-time repayment of the loan?


+*In[17]:*+
[source, ipython3]
----
purposeData = creditScore.groupby('purpose')
print(purposeData['debt'].describe())
print(purposeData['debt'].count()/purposeData['debt'].sum())
----


+*Out[17]:*+
----
               count      mean       std  min  25%  50%  75%  max
purpose                                                          
car           4271.0  0.094123  0.292034  0.0  0.0  0.0  0.0  1.0
education     3964.0  0.093340  0.290945  0.0  0.0  0.0  0.0  1.0
real estate  10576.0  0.073846  0.261533  0.0  0.0  0.0  0.0  1.0
wedding       2306.0  0.080659  0.272370  0.0  0.0  0.0  0.0  1.0
purpose
car            10.624378
education      10.713514
real estate    13.541613
wedding        12.397849
Name: debt, dtype: float64
----


+*In[18]:*+
[source, ipython3]
----
creditScore.pivot_table(index = 'purpose',values = 'debt', aggfunc = ['count', 'mean'])
----


+*Out[18]:*+
----
count

mean

debt

debt

purpose

car

4271

0.094123

education

3964

0.093340

real estate

10576

0.073846

wedding

2306

0.080659
----

Reviewer’s comment v. 1:

Could you please describe all main results of the project (data
preparation, anomalies, main findings and so on)?

I started by grouping the data by the `purpose' column.

Looking at the data: 781/10576 = 13.5% of those with debt took it out
for real estate purpoes, 186/2306 = 12.4% of those with debt took it out
for wedding purposes, 370/3964 = 10.7% of those with debt took it out
for education purposes and 402/4271 = 10.6% of those with debt took it
out for car purchase purposes.

From this data, we can conclude that most people take out loans for real
estate purposes (50% of people who took out debt took it out for real
estate purposes). As a result, the number of those who have debt and
took out that debt for real estate purposes is going to be the highest.
Those who took out loans for real estate or wedding purposes are less
likely to repay their loans on time than those who took out loans for
car or education purposes.

== Step 4. General Conclusion

From this data, we can conclude that there is a relation income level
and repaying the loan on time. Those who either were employed (retired)
or are employed by an external entity (business, civil servent,
employee) have high percentage of debt than those who are either self
employed (entrepreneur), on paternity / maternity leave, a student or
unemployed.

In conclusion:

-Those who have children are generally more likely to repay their loans
on time, compared to those who do not have children. Those who have been
married or are currently maried are generally more likely to have debt
than those who have never been married or are not married.

-Most people take out loans for real estate purposes. Those who take out
loans for real estate or wedding purposes are less likely to repay their
loans on time.

-Those who either were employed (retired) or are currently employed by
an external entity (business, civil servant,employee) are more likely to
have debt than those who are either self-employed (entrepreneur), on
paternity / maternity leave, a student or unemployed.

Reviewer’s comment v. 3:

An excellent conclusion which highlights all the main results of the
project. You correctly find the most risky categories of clients.
Definitely, this information will be useful for a bank’s loan division.


+*In[ ]:*+
[source, ipython3]
----

----
